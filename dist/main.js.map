{
  "version": 3,
  "sources": ["../src/foundry/constants.ts", "../src/foundry/settings.ts", "../src/data/schema.ts", "../src/data/store.ts", "../src/foundry/regions.ts", "../src/foundry/logger.ts", "../src/foundry/io.ts", "../src/data/indexer.ts", "../src/foundry/grid-selection.ts", "../src/foundry/spawn.ts", "../src/ui/app.ts", "../src/main.ts"],
  "sourcesContent": ["export const MODULE_ID = \"pf2e-encounter-adjuster\";\nexport const SETTINGS_KEYS = {\n  debug: \"debugLogging\",\n  compendiums: \"compendiumPacks\",\n  linkedMode: \"spawnLinked\",\n  allowStacking: \"defaultAllowStacking\",\n  maxTokens: \"maxTokensPerPopulate\",\n  encounterData: \"encounterData\",\n  monsterIndex: \"monsterIndex\"\n} as const;\n\nexport const DEFAULT_COMPENDIUMS = [\n  \"pf2e.pathfinder-monster-core\",\n  \"pf2e.npc-core\"\n];\n", "import { DEFAULT_COMPENDIUMS, MODULE_ID, SETTINGS_KEYS } from \"./constants\";\n\nexport function registerSettings(): void {\n  game.settings.register(MODULE_ID, SETTINGS_KEYS.debug, {\n    name: game.i18n.localize(\"PF2E_EA.Settings.Debug\"),\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: false\n  });\n\n  game.settings.register(MODULE_ID, SETTINGS_KEYS.compendiums, {\n    name: game.i18n.localize(\"PF2E_EA.Settings.Compendiums\"),\n    hint: \"Z. B. pf2e.pathfinder-monster-core,pf2e.npc-core\",\n    scope: \"world\",\n    config: true,\n    type: String,\n    default: DEFAULT_COMPENDIUMS.join(\",\")\n  });\n\n  game.settings.register(MODULE_ID, SETTINGS_KEYS.linkedMode, {\n    name: game.i18n.localize(\"PF2E_EA.Settings.LinkedMode\"),\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: false\n  });\n\n  game.settings.register(MODULE_ID, SETTINGS_KEYS.allowStacking, {\n    name: game.i18n.localize(\"PF2E_EA.Settings.AllowStacking\"),\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: false\n  });\n\n  game.settings.register(MODULE_ID, SETTINGS_KEYS.maxTokens, {\n    name: game.i18n.localize(\"PF2E_EA.Settings.MaxTokens\"),\n    scope: \"world\",\n    config: true,\n    type: Number,\n    range: { min: 1, max: 1000, step: 1 },\n    default: 250\n  });\n\n  game.settings.register(MODULE_ID, SETTINGS_KEYS.encounterData, {\n    name: \"Encounter Datastore\",\n    scope: \"world\",\n    config: false,\n    type: Object,\n    default: { schemaVersion: 1, scenes: [] }\n  });\n\n  game.settings.register(MODULE_ID, SETTINGS_KEYS.monsterIndex, {\n    name: \"Monster Index Cache\",\n    scope: \"world\",\n    config: false,\n    type: Object,\n    default: { builtAt: null, entries: [] }\n  });\n}\n\nexport function getCompendiumList(): string[] {\n  const raw = String(game.settings.get(MODULE_ID, SETTINGS_KEYS.compendiums) ?? \"\");\n  return raw.split(\",\").map((x) => x.trim()).filter(Boolean);\n}\n", "export type SceneRef = { sceneId?: string; sceneUuid?: string; name?: string };\nexport type PlacementArea =\n  | { rect: { x: number; y: number; w: number; h: number } }\n  | { points: Array<{ x: number; y: number }> };\n\nexport interface PlacementAreaRef {\n  type: \"region\";\n  regionId?: string;\n  regionName?: string;\n  roomLabel?: string;\n}\n\nexport interface Placement {\n  areaRef?: PlacementAreaRef | string;\n  monster: {\n    uuid?: string;\n    slug?: string;\n    name: string;\n    sourceHint?: string;\n    levelHint?: number;\n  };\n  quantity: number;\n  area?: PlacementArea;\n  tags?: string[];\n  token?: {\n    disposition?: number;\n    hidden?: boolean;\n    elevation?: number;\n    scale?: number;\n    rotation?: number;\n  };\n  spawnRules?: {\n    allowStacking?: boolean;\n    randomizeWithinArea?: boolean;\n  };\n}\n\nexport interface EncounterTemplate {\n  id: string;\n  label: string;\n  notes?: string;\n  placements: Placement[];\n}\n\nexport interface ImportedScene {\n  sceneRef: SceneRef;\n  encounters: EncounterTemplate[];\n}\n\nexport interface EncounterImport {\n  schemaVersion: 1;\n  adventureId?: string;\n  sourceTitle?: string;\n  generatedAt: string;\n  scenes: ImportedScene[];\n}\n\nexport interface ValidationErrorItem {\n  path: string;\n  message: string;\n}\n\nconst isObj = (value: unknown): value is Record<string, unknown> =>\n  Boolean(value && typeof value === \"object\" && !Array.isArray(value));\n\nexport function validateEncounterImport(input: unknown): { ok: true; data: EncounterImport } | { ok: false; errors: ValidationErrorItem[] } {\n  const errors: ValidationErrorItem[] = [];\n  if (!isObj(input)) {\n    return { ok: false, errors: [{ path: \"$\", message: \"JSON root must be an object.\" }] };\n  }\n\n  if (input.schemaVersion !== 1) {\n    errors.push({ path: \"schemaVersion\", message: \"schemaVersion must be 1.\" });\n  }\n\n  if (typeof input.generatedAt !== \"string\") {\n    errors.push({ path: \"generatedAt\", message: \"generatedAt must be an ISO date string.\" });\n  }\n\n  if (!Array.isArray(input.scenes)) {\n    errors.push({ path: \"scenes\", message: \"scenes must be an array.\" });\n  } else {\n    input.scenes.forEach((scene, sIdx) => {\n      if (!isObj(scene) || !isObj(scene.sceneRef) || !Array.isArray(scene.encounters)) {\n        errors.push({ path: `scenes[${sIdx}]`, message: \"scene entry must contain sceneRef and encounters.\" });\n        return;\n      }\n\n      scene.encounters.forEach((enc, eIdx) => {\n        if (!isObj(enc) || typeof enc.id !== \"string\" || typeof enc.label !== \"string\" || !Array.isArray(enc.placements)) {\n          errors.push({ path: `scenes[${sIdx}].encounters[${eIdx}]`, message: \"encounter must have id, label, placements.\" });\n          return;\n        }\n\n        enc.placements.forEach((placement, pIdx) => {\n          if (!isObj(placement) || !isObj(placement.monster) || typeof placement.quantity !== \"number\") {\n            errors.push({ path: `scenes[${sIdx}].encounters[${eIdx}].placements[${pIdx}]`, message: \"placement must contain monster and quantity.\" });\n            return;\n          }\n          if (placement.quantity < 1 || placement.quantity > 999) {\n            errors.push({ path: `scenes[${sIdx}].encounters[${eIdx}].placements[${pIdx}].quantity`, message: \"quantity out of allowed range 1..999.\" });\n          }\n          const hasArea = isObj(placement.area) && (\"rect\" in placement.area || \"points\" in placement.area);\n          const hasAreaRefObject = isObj(placement.areaRef);\n          const hasAreaRefString = typeof placement.areaRef === \"string\" && placement.areaRef.trim().length > 0;\n          if (!hasArea && !hasAreaRefObject && !hasAreaRefString) {\n            errors.push({ path: `scenes[${sIdx}].encounters[${eIdx}].placements[${pIdx}]`, message: \"placement requires area or areaRef.\" });\n          }\n\n          if (hasAreaRefObject) {\n            const areaRefObj = placement.areaRef as Record<string, unknown>;\n            if (areaRefObj.type !== \"region\") {\n              errors.push({ path: `scenes[${sIdx}].encounters[${eIdx}].placements[${pIdx}].areaRef.type`, message: \"areaRef.type must be 'region'.\" });\n            }\n            const hasRegionReference =\n              typeof areaRefObj.regionId === \"string\" ||\n              typeof areaRefObj.regionName === \"string\" ||\n              typeof areaRefObj.roomLabel === \"string\";\n            if (!hasRegionReference) {\n              errors.push({ path: `scenes[${sIdx}].encounters[${eIdx}].placements[${pIdx}].areaRef`, message: \"areaRef requires regionId, regionName or roomLabel.\" });\n            }\n          }\n          if (typeof placement.monster.name !== \"string\") {\n            errors.push({ path: `scenes[${sIdx}].encounters[${eIdx}].placements[${pIdx}].monster.name`, message: \"monster.name must be string.\" });\n          }\n        });\n      });\n    });\n  }\n\n  if (errors.length) return { ok: false, errors };\n  return { ok: true, data: input as unknown as EncounterImport };\n}\n", "import { MODULE_ID, SETTINGS_KEYS } from \"../foundry/constants\";\nimport type { EncounterImport } from \"./schema\";\n\nexport function getEncounterData(): EncounterImport {\n  return game.settings.get(MODULE_ID, SETTINGS_KEYS.encounterData) as EncounterImport;\n}\n\nexport async function setEncounterData(data: EncounterImport): Promise<void> {\n  await game.settings.set(MODULE_ID, SETTINGS_KEYS.encounterData, data);\n}\n\nexport function getMonsterIndex(): any {\n  return game.settings.get(MODULE_ID, SETTINGS_KEYS.monsterIndex);\n}\n\nexport async function setMonsterIndex(data: any): Promise<void> {\n  await game.settings.set(MODULE_ID, SETTINGS_KEYS.monsterIndex, data);\n}\n", "export interface RegionAreaRef {\n  type: \"region\";\n  regionId?: string;\n  regionName?: string;\n  roomLabel?: string;\n}\n\nexport function normalizeRegionText(value: string): string {\n  return value.toLowerCase().trim().replace(/\\s+/g, \" \");\n}\n\nexport function extractRoomCode(value?: string): string | null {\n  if (!value) return null;\n  const normalized = normalizeRegionText(value).replace(/^[\\s.]+|[\\s.]+$/g, \"\");\n  const match = normalized.match(/^([a-z]+[0-9]+)\\b/);\n  return match?.[1] ?? null;\n}\n\nexport function getSceneRegions(scene: any): any[] {\n  const direct = scene?.regions;\n  if (direct && typeof direct[Symbol.iterator] === \"function\") {\n    return Array.from(direct);\n  }\n\n  const embedded = scene?.getEmbeddedCollection?.(\"Region\");\n  if (embedded && typeof embedded[Symbol.iterator] === \"function\") {\n    return Array.from(embedded);\n  }\n\n  return [];\n}\n\nexport function resolveRegion(scene: any, areaRef?: RegionAreaRef | null): any | null {\n  if (!areaRef || areaRef.type !== \"region\") return null;\n  const regions = getSceneRegions(scene);\n\n  if (areaRef.regionId) {\n    const byId = regions.find((region) => String(region.id) === String(areaRef.regionId));\n    if (byId) return byId;\n  }\n\n  const label = areaRef.roomLabel || areaRef.regionName;\n  if (!label) return null;\n\n  const codeWanted = extractRoomCode(label);\n  if (codeWanted) {\n    const byCode = regions.find((region) => extractRoomCode(String(region.name ?? \"\")) === codeWanted);\n    if (byCode) return byCode;\n  }\n\n  const normalizedLabel = normalizeRegionText(label);\n  return regions.find((region) => normalizeRegionText(String(region.name ?? \"\")).startsWith(normalizedLabel)) ?? null;\n}\n\nfunction getGridSize(scene: any): number {\n  return Number(scene?.grid?.size ?? scene?.dimensions?.size ?? 0);\n}\n\nfunction regionBounds(region: any): { x: number; y: number; w: number; h: number } | null {\n  const bounds = region?.bounds;\n  if (bounds && Number.isFinite(bounds.x) && Number.isFinite(bounds.y) && Number.isFinite(bounds.width ?? bounds.w) && Number.isFinite(bounds.height ?? bounds.h)) {\n    return {\n      x: Number(bounds.x),\n      y: Number(bounds.y),\n      w: Number(bounds.width ?? bounds.w),\n      h: Number(bounds.height ?? bounds.h)\n    };\n  }\n\n  const shapeData = Array.isArray(region?.shapes) ? region.shapes : Array.isArray(region?._source?.shapes) ? region._source.shapes : [];\n  if (!shapeData.length) return null;\n\n  let minX = Number.POSITIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n\n  for (const shape of shapeData) {\n    const x = Number(shape.x ?? 0);\n    const y = Number(shape.y ?? 0);\n    if (Array.isArray(shape.points) && shape.points.length >= 2) {\n      for (let i = 0; i < shape.points.length; i += 2) {\n        const px = x + Number(shape.points[i] ?? 0);\n        const py = y + Number(shape.points[i + 1] ?? 0);\n        minX = Math.min(minX, px);\n        minY = Math.min(minY, py);\n        maxX = Math.max(maxX, px);\n        maxY = Math.max(maxY, py);\n      }\n    } else {\n      const w = Number(shape.width ?? shape.w ?? 0);\n      const h = Number(shape.height ?? shape.h ?? 0);\n      minX = Math.min(minX, x);\n      minY = Math.min(minY, y);\n      maxX = Math.max(maxX, x + w);\n      maxY = Math.max(maxY, y + h);\n    }\n  }\n\n  if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) return null;\n  return { x: minX, y: minY, w: Math.max(0, maxX - minX), h: Math.max(0, maxY - minY) };\n}\n\nfunction pointInPolygon(px: number, py: number, points: number[]): boolean {\n  let inside = false;\n  for (let i = 0, j = points.length - 2; i < points.length; i += 2) {\n    const xi = points[i];\n    const yi = points[i + 1];\n    const xj = points[j];\n    const yj = points[j + 1];\n    const intersect = yi > py !== yj > py && px < ((xj - xi) * (py - yi)) / ((yj - yi) || Number.EPSILON) + xi;\n    if (intersect) inside = !inside;\n    j = i;\n  }\n  return inside;\n}\n\nfunction shapeContainsPoint(shape: any, px: number, py: number): boolean {\n  const type = String(shape.type ?? shape.shape ?? \"rectangle\").toLowerCase();\n  const x = Number(shape.x ?? 0);\n  const y = Number(shape.y ?? 0);\n\n  if (Array.isArray(shape.points) && shape.points.length >= 6) {\n    const worldPoints = shape.points.map((v: number, idx: number) => Number(v) + (idx % 2 === 0 ? x : y));\n    return pointInPolygon(px, py, worldPoints);\n  }\n\n  const w = Number(shape.width ?? shape.w ?? 0);\n  const h = Number(shape.height ?? shape.h ?? 0);\n\n  if (type.includes(\"ellipse\")) {\n    if (!w || !h) return false;\n    const rx = w / 2;\n    const ry = h / 2;\n    const cx = x + rx;\n    const cy = y + ry;\n    const nx = (px - cx) / rx;\n    const ny = (py - cy) / ry;\n    return nx * nx + ny * ny <= 1;\n  }\n\n  return px >= x && py >= y && px <= x + w && py <= y + h;\n}\n\nfunction regionContainsPoint(region: any, px: number, py: number): boolean {\n  if (typeof region?.containsPoint === \"function\") {\n    return Boolean(region.containsPoint({ x: px, y: py }));\n  }\n\n  const shapeData = Array.isArray(region?.shapes) ? region.shapes : Array.isArray(region?._source?.shapes) ? region._source.shapes : [];\n  return shapeData.some((shape: any) => shapeContainsPoint(shape, px, py));\n}\n\nexport function regionToGridCells(scene: any, region: any): Array<{ x: number; y: number }> {\n  const gridSize = getGridSize(scene);\n  const bounds = regionBounds(region);\n  if (!gridSize || !bounds) return [];\n\n  const minX = Math.floor(bounds.x / gridSize);\n  const minY = Math.floor(bounds.y / gridSize);\n  const maxX = Math.ceil((bounds.x + bounds.w) / gridSize);\n  const maxY = Math.ceil((bounds.y + bounds.h) / gridSize);\n\n  const cells: Array<{ x: number; y: number }> = [];\n  for (let y = minY; y < maxY; y++) {\n    for (let x = minX; x < maxX; x++) {\n      const px = x * gridSize + gridSize / 2;\n      const py = y * gridSize + gridSize / 2;\n      if (regionContainsPoint(region, px, py)) cells.push({ x, y });\n    }\n  }\n\n  return cells;\n}\n", "import { MODULE_ID, SETTINGS_KEYS } from \"./constants\";\n\nexport function isDebugEnabled(): boolean {\n  return Boolean(game.settings.get(MODULE_ID, SETTINGS_KEYS.debug));\n}\n\nexport function logDebug(message: string, data?: unknown): void {\n  if (!isDebugEnabled()) return;\n  console.debug(`[${MODULE_ID}] ${message}`, data ?? \"\");\n}\n\nexport function logInfo(message: string): void {\n  console.info(`[${MODULE_ID}] ${message}`);\n}\n\nexport function logError(message: string, err?: unknown): void {\n  console.error(`[${MODULE_ID}] ${message}`, err ?? \"\");\n}\n", "import { validateEncounterImport } from \"../data/schema\";\nimport { getEncounterData, setEncounterData } from \"../data/store\";\nimport { getSceneRegions } from \"./regions\";\nimport { logError, logInfo } from \"./logger\";\n\nfunction regionBounds(region: any): { x: number; y: number; w: number; h: number } | null {\n  const bounds = region?.bounds;\n  if (!bounds) return null;\n  const width = Number(bounds.width ?? bounds.w);\n  const height = Number(bounds.height ?? bounds.h);\n  if (!Number.isFinite(bounds.x) || !Number.isFinite(bounds.y) || !Number.isFinite(width) || !Number.isFinite(height)) {\n    return null;\n  }\n  return { x: Number(bounds.x), y: Number(bounds.y), w: width, h: height };\n}\n\nexport function buildScenesExport(): any {\n  return {\n    foundryVersion: game.version,\n    systemId: game.system.id,\n    worldId: game.world?.id ?? null,\n    generatedAt: new Date().toISOString(),\n    scenes: game.scenes.map((scene: any) => ({\n      sceneId: scene.id,\n      sceneUuid: scene.uuid,\n      name: scene.name,\n      gridSize: scene.grid?.size,\n      width: scene.width,\n      height: scene.height,\n      background: scene.background?.src ?? null,\n      notes: scene?.flags?.notes ?? null,\n      regions: getSceneRegions(scene).map((region: any) => {\n        const bounds = regionBounds(region);\n        return {\n          id: String(region.id),\n          name: String(region.name ?? \"\"),\n          ...(bounds ? { bounds } : {})\n        };\n      })\n    }))\n  };\n}\n\nexport async function exportScenesJson(copyToClipboard = false): Promise<void> {\n  const data = buildScenesExport();\n  const json = JSON.stringify(data, null, 2);\n  const blob = new Blob([json], { type: \"application/json\" });\n  const filename = `scene-export-${Date.now()}.json`;\n  saveDataToFile(blob, \"application/json\", filename);\n  if (copyToClipboard && navigator.clipboard) {\n    await navigator.clipboard.writeText(json);\n  }\n  logInfo(\"Scene export created.\");\n}\n\nfunction summarizeAreaRefs(data: any): { byRegionId: number; byLabel: number } {\n  let byRegionId = 0;\n  let byLabel = 0;\n  for (const scene of data.scenes ?? []) {\n    for (const encounter of scene.encounters ?? []) {\n      for (const placement of encounter.placements ?? []) {\n        const areaRef = placement?.areaRef;\n        if (!areaRef || areaRef.type !== \"region\") continue;\n        if (areaRef.regionId) byRegionId++;\n        if (areaRef.roomLabel || areaRef.regionName) byLabel++;\n      }\n    }\n  }\n  return { byRegionId, byLabel };\n}\n\nexport async function importEncounterJson(raw: string): Promise<void> {\n  let parsed: unknown;\n  try {\n    parsed = JSON.parse(raw);\n  } catch (err) {\n    logError(\"Invalid JSON parse\", err);\n    ui.notifications.error(\"Import fehlgeschlagen: ung\u00FCltiges JSON.\");\n    return;\n  }\n\n  const validation = validateEncounterImport(parsed);\n  if (!validation.ok) {\n    const msg = validation.errors.map((e) => `${e.path}: ${e.message}`).join(\"\\n\");\n    ui.notifications.error(\"Schema-Validierung fehlgeschlagen. Details in Dialog.\");\n    await Dialog.prompt({\n      title: \"Import-Fehler\",\n      content: `<pre>${msg}</pre>`\n    });\n    return;\n  }\n\n  await setEncounterData(validation.data);\n  const summary = summarizeAreaRefs(validation.data);\n  logInfo(\"Encounter data imported.\");\n  ui.notifications.info(\"Encounter JSON erfolgreich importiert.\");\n  if (summary.byRegionId || summary.byLabel) {\n    ui.notifications.info(`Region-Referenzen erkannt: ${summary.byRegionId} per regionId, ${summary.byLabel} per roomLabel/regionName.`);\n  }\n}\n\nexport async function promptImportDialog(): Promise<void> {\n  const content = await renderTemplate(\"modules/pf2e-encounter-adjuster/templates/import-dialog.hbs\", {});\n  new Dialog({\n    title: \"Import Encounter JSON\",\n    content,\n    buttons: {\n      import: {\n        label: \"Importieren\",\n        callback: async (html: any) => {\n          const text = html.find(\"textarea[name='encounter-json']\").val();\n          if (text) {\n            await importEncounterJson(String(text));\n            return;\n          }\n          const fileInput = html.find(\"input[name='encounter-file']\")[0] as HTMLInputElement;\n          const file = fileInput?.files?.[0];\n          if (!file) {\n            ui.notifications.warn(\"Bitte Datei w\u00E4hlen oder JSON einf\u00FCgen.\");\n            return;\n          }\n          const raw = await file.text();\n          await importEncounterJson(raw);\n        }\n      }\n    },\n    default: \"import\"\n  }).render(true);\n}\n\nexport function getStoredEncounterData(): any {\n  return getEncounterData();\n}\n", "import { getCompendiumList } from \"../foundry/settings\";\nimport { logDebug, logInfo } from \"../foundry/logger\";\nimport { getMonsterIndex, setMonsterIndex } from \"./store\";\n\nexport interface MonsterIndexEntry {\n  uuid: string;\n  name: string;\n  slug?: string;\n  img?: string;\n  type?: string;\n  level?: number;\n  traits?: string[];\n  sourcePack?: string;\n}\n\nfunction isCreature(actor: any): boolean {\n  const type = String(actor?.type ?? \"\").toLowerCase();\n  return [\"npc\", \"creature\", \"hazard\"].includes(type);\n}\n\nfunction toEntry(actor: any, sourcePack?: string): MonsterIndexEntry {\n  return {\n    uuid: actor.uuid,\n    name: actor.name,\n    slug: actor?.system?.slug,\n    img: actor.img,\n    type: actor.type,\n    level: actor?.system?.details?.level?.value,\n    traits: actor?.system?.traits?.value ?? [],\n    sourcePack\n  };\n}\n\nexport async function rebuildMonsterIndex(): Promise<{ count: number }> {\n  const entries: MonsterIndexEntry[] = [];\n\n  for (const actor of game.actors) {\n    if (isCreature(actor)) entries.push(toEntry(actor));\n  }\n\n  for (const packId of getCompendiumList()) {\n    const pack = game.packs.get(packId);\n    if (!pack || pack.documentName !== \"Actor\") continue;\n    const docs = await pack.getDocuments();\n    for (const actor of docs) {\n      if (isCreature(actor)) entries.push(toEntry(actor, packId));\n    }\n  }\n\n  await setMonsterIndex({ builtAt: new Date().toISOString(), entries });\n  logInfo(`Monster index rebuilt (${entries.length} entries).`);\n  return { count: entries.length };\n}\n\nfunction norm(value: string): string {\n  return value.trim().toLowerCase().normalize(\"NFD\").replace(/\\p{Diacritic}/gu, \"\");\n}\n\nexport async function resolveMonster(monster: any): Promise<{ status: \"resolved\" | \"unresolved\" | \"conflict\"; entry?: MonsterIndexEntry; candidates?: MonsterIndexEntry[] }> {\n  if (monster.uuid) {\n    const doc = await fromUuidSafe(monster.uuid);\n    if (doc) return { status: \"resolved\", entry: toEntry(doc) };\n  }\n\n  const index = getMonsterIndex();\n  const entries: MonsterIndexEntry[] = index?.entries ?? [];\n\n  if (monster.slug) {\n    const slugMatches = entries.filter((e) => e.slug === monster.slug);\n    const filtered = slugMatches.filter((e) => {\n      const okLevel = typeof monster.levelHint !== \"number\" || e.level === monster.levelHint;\n      const okSource = !monster.sourceHint || (e.sourcePack ?? \"\").includes(monster.sourceHint);\n      return okLevel && okSource;\n    });\n    if (filtered.length === 1) return { status: \"resolved\", entry: filtered[0] };\n    if (filtered.length > 1) return { status: \"conflict\", candidates: filtered };\n  }\n\n  const nameMatches = entries.filter((e) => norm(e.name) === norm(monster.name));\n  if (nameMatches.length === 1) return { status: \"resolved\", entry: nameMatches[0] };\n  if (nameMatches.length > 1) return { status: \"conflict\", candidates: nameMatches };\n\n  logDebug(\"Monster unresolved\", monster);\n  return { status: \"unresolved\" };\n}\n\nasync function fromUuidSafe(uuid: string): Promise<any | null> {\n  try {\n    return await fromUuid(uuid);\n  } catch {\n    return null;\n  }\n}\n", "import { logDebug } from \"./logger\";\n\nexport class GridSelectionManager {\n  private static _instance: GridSelectionManager;\n  private active = false;\n  private selected = new Set<string>();\n\n  static get instance(): GridSelectionManager {\n    if (!this._instance) this._instance = new GridSelectionManager();\n    return this._instance;\n  }\n\n  activate(): void {\n    this.active = true;\n    ui.notifications.info(\"Grid-Auswahl aktiviert. Klick zum Toggle, Drag f\u00FCr Rechteck.\");\n    logDebug(\"Grid selection activated.\");\n  }\n\n  deactivate(): void {\n    this.active = false;\n  }\n\n  clear(): void {\n    this.selected.clear();\n  }\n\n  toggleCell(x: number, y: number): void {\n    const key = `${x},${y}`;\n    if (this.selected.has(key)) this.selected.delete(key);\n    else this.selected.add(key);\n  }\n\n  setRectangle(x1: number, y1: number, x2: number, y2: number): void {\n    for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {\n      for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {\n        this.selected.add(`${x},${y}`);\n      }\n    }\n  }\n\n  getCells(): Array<{ x: number; y: number }> {\n    return [...this.selected].map((k) => {\n      const [x, y] = k.split(\",\").map((v) => Number(v));\n      return { x, y };\n    });\n  }\n\n  isActive(): boolean {\n    return this.active;\n  }\n}\n", "import { resolveMonster } from \"../data/indexer\";\nimport { MODULE_ID, SETTINGS_KEYS } from \"./constants\";\nimport { regionToGridCells, resolveRegion } from \"./regions\";\n\nfunction cellsFromArea(area: any): Array<{ x: number; y: number }> {\n  if (area?.rect) {\n    const cells: Array<{ x: number; y: number }> = [];\n    for (let y = area.rect.y; y < area.rect.y + area.rect.h; y++) {\n      for (let x = area.rect.x; x < area.rect.x + area.rect.w; x++) cells.push({ x, y });\n    }\n    return cells;\n  }\n  if (Array.isArray(area?.points)) return area.points;\n  return [];\n}\n\nfunction shuffle<T>(arr: T[]): T[] {\n  const clone = [...arr];\n  for (let i = clone.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [clone[i], clone[j]] = [clone[j], clone[i]];\n  }\n  return clone;\n}\n\nfunction areaRefLabel(areaRef: any): string {\n  if (!areaRef) return \"\";\n  if (areaRef.type === \"region\") return areaRef.roomLabel || areaRef.regionName || areaRef.regionId || \"region\";\n  return String(areaRef);\n}\n\nfunction getPlacementCells(scene: any, placement: any, selectedCells: Array<{ x: number; y: number }>): { cells: Array<{ x: number; y: number }>; unresolvedRegion: boolean } {\n  if (selectedCells.length) {\n    return { cells: selectedCells, unresolvedRegion: false };\n  }\n\n  if (placement.area) {\n    return { cells: cellsFromArea(placement.area), unresolvedRegion: false };\n  }\n\n  if (placement.areaRef?.type === \"region\") {\n    const region = resolveRegion(scene, placement.areaRef);\n    if (!region) return { cells: [], unresolvedRegion: true };\n    return { cells: regionToGridCells(scene, region), unresolvedRegion: false };\n  }\n\n  return { cells: [], unresolvedRegion: false };\n}\n\nexport async function previewPopulate(scene: any, placements: any[], selectedCells: Array<{ x: number; y: number }>): Promise<string[]> {\n  const warnings: string[] = [];\n  const unresolved: string[] = [];\n  const unresolvedRegions: string[] = [];\n  let total = 0;\n  for (const p of placements) {\n    const res = await resolveMonster(p.monster);\n    if (res.status !== \"resolved\") unresolved.push(p.areaRef ? `${p.monster.name} [${areaRefLabel(p.areaRef)}]` : p.monster.name);\n    if (!selectedCells.length && p.areaRef?.type === \"region\" && !resolveRegion(scene, p.areaRef)) {\n      unresolvedRegions.push(areaRefLabel(p.areaRef));\n    }\n    total += p.quantity;\n  }\n  const max = Number(game.settings.get(MODULE_ID, SETTINGS_KEYS.maxTokens));\n  if (total > max) warnings.push(`Token-Limit \u00FCberschritten (${total}/${max}).`);\n  if (unresolved.length) warnings.push(`Unresolved Monster: ${unresolved.join(\", \")}`);\n  if (unresolvedRegions.length) warnings.push(`Unresolved Regions: ${unresolvedRegions.join(\", \")}`);\n  if (selectedCells.length && total > selectedCells.length) warnings.push(\"Mehr Tokens als ausgew\u00E4hlte Squares.\");\n  return warnings;\n}\n\nexport async function populateScene(scene: any, placements: any[], selectedCells: Array<{ x: number; y: number }>): Promise<void> {\n  const max = Number(game.settings.get(MODULE_ID, SETTINGS_KEYS.maxTokens));\n  const linked = Boolean(game.settings.get(MODULE_ID, SETTINGS_KEYS.linkedMode));\n  const defaultAllowStacking = Boolean(game.settings.get(MODULE_ID, SETTINGS_KEYS.allowStacking));\n\n  const docs: any[] = [];\n  let total = 0;\n\n  for (const placement of placements) {\n    total += placement.quantity;\n    if (total > max) throw new Error(`Max token limit exceeded (${max}).`);\n\n    const resolved = await resolveMonster(placement.monster);\n    if (resolved.status !== \"resolved\" || !resolved.entry) continue;\n\n    const actor = await fromUuid(resolved.entry.uuid);\n    if (!actor) continue;\n\n    const { cells: rawCells, unresolvedRegion } = getPlacementCells(scene, placement, selectedCells);\n    if (unresolvedRegion) {\n      ui.notifications.warn(`Region f\u00FCr Raumlabel ${areaRefLabel(placement.areaRef)} nicht gefunden.`);\n      continue;\n    }\n\n    if (!rawCells.length) {\n      ui.notifications.warn(`Keine Grid-Zellen f\u00FCr Placement ${placement.monster.name} (${areaRefLabel(placement.areaRef)}).`);\n      continue;\n    }\n\n    const randomized = placement.spawnRules?.randomizeWithinArea ? shuffle(rawCells) : [...rawCells];\n    const allowStacking = placement.spawnRules?.allowStacking ?? defaultAllowStacking;\n    const available = allowStacking ? randomized : randomized.slice(0, placement.quantity);\n\n    if (!allowStacking && placement.quantity > available.length) {\n      const areaSuffix = areaRefLabel(placement.areaRef) ? ` [${areaRefLabel(placement.areaRef)}]` : \"\";\n      throw new Error(`Not enough cells for placement ${placement.monster.name}${areaSuffix}.`);\n    }\n\n    for (let i = 0; i < placement.quantity; i++) {\n      const cell = allowStacking\n        ? randomized[i % Math.max(1, randomized.length)]\n        : available[i];\n      if (!cell) continue;\n      const px = cell.x * scene.grid.size + scene.grid.size / 2;\n      const py = cell.y * scene.grid.size + scene.grid.size / 2;\n      docs.push({\n        actorId: actor.id,\n        x: px,\n        y: py,\n        hidden: placement.token?.hidden ?? false,\n        elevation: placement.token?.elevation ?? 0,\n        rotation: placement.token?.rotation ?? 0,\n        disposition: placement.token?.disposition ?? CONST.TOKEN_DISPOSITIONS.HOSTILE,\n        actorLink: linked,\n        texture: {\n          scaleX: placement.token?.scale ?? 1,\n          scaleY: placement.token?.scale ?? 1\n        }\n      });\n    }\n  }\n\n  if (!docs.length) {\n    ui.notifications.warn(\"Keine spawnbaren Tokens gefunden.\");\n    return;\n  }\n\n  await scene.createEmbeddedDocuments(\"Token\", docs);\n  ui.notifications.info(`${docs.length} Token gespawnt.`);\n}\n", "import { getStoredEncounterData } from \"../foundry/io\";\nimport { GridSelectionManager } from \"../foundry/grid-selection\";\nimport { populateScene, previewPopulate } from \"../foundry/spawn\";\nimport { resolveMonster } from \"../data/indexer\";\nimport { resolveRegion } from \"../foundry/regions\";\n\nconst BaseApp: any = foundry?.applications?.api?.ApplicationV2 ?? Application;\n\nfunction areaRefDisplay(areaRef: any): string {\n  if (!areaRef) return \"\";\n  if (areaRef.type === \"region\") {\n    return areaRef.roomLabel || areaRef.regionName || areaRef.regionId || \"Region\";\n  }\n  return String(areaRef);\n}\n\nexport class EncounterAdjusterApp extends BaseApp {\n  declare render: (force?: boolean) => unknown;\n  static DEFAULT_OPTIONS = {\n    id: \"pf2e-encounter-adjuster-app\",\n    classes: [\"pf2e-encounter-adjuster\"],\n    window: { title: \"Encounter Adjuster\", resizable: true },\n    position: { width: 900, height: 700 }\n  };\n\n  async _prepareContext(): Promise<any> {\n    const data = getStoredEncounterData();\n    const scenes = (data.scenes ?? []).map((s: any, idx: number) => ({ idx, name: s.sceneRef?.name || s.sceneRef?.sceneId || `Szene ${idx + 1}` }));\n    const selectedScene = data.scenes?.[0];\n    const selectedEncounter = selectedScene?.encounters?.[0];\n    const sceneId = selectedScene?.sceneRef?.sceneId;\n    const sceneDoc = game.scenes.get(sceneId) ?? canvas.scene;\n\n    const placementRows = (selectedEncounter?.placements ?? []).map((placement: any) => {\n      const isRegion = placement.areaRef?.type === \"region\";\n      const regionLabel = isRegion ? areaRefDisplay(placement.areaRef) : \"\";\n      const unresolvedRegion = isRegion && !resolveRegion(sceneDoc, placement.areaRef);\n      return {\n        ...placement,\n        areaLabel: placement.area?.rect ? \"Rect\" : placement.area?.points ? \"Polygon\" : \"-\",\n        regionLabel,\n        hasRegion: isRegion,\n        unresolvedRegion,\n        unresolvedRegionTooltip: `Region f\u00FCr Raumlabel ${regionLabel} nicht gefunden`\n      };\n    });\n\n    const activeSceneId = canvas?.scene?.id ?? \"\";\n    return {\n      scenes,\n      data,\n      activeSceneId,\n      selectedCells: GridSelectionManager.instance.getCells().length,\n      placementRows\n    };\n  }\n\n  async _renderHTML(context: any): Promise<string> {\n    return renderTemplate(\"modules/pf2e-encounter-adjuster/templates/app.hbs\", context);\n  }\n\n  async _replaceHTML(result: string, content: HTMLElement): Promise<void> {\n    content.innerHTML = result;\n  }\n\n  activateListeners(html: any): void {\n    super.activateListeners?.(html);\n    html.find(\"button[data-action='activate-grid']\").on(\"click\", () => GridSelectionManager.instance.activate());\n    html.find(\"button[data-action='clear-grid']\").on(\"click\", () => {\n      GridSelectionManager.instance.clear();\n      this.render();\n    });\n\n    html.find(\"button[data-action='preview']\").on(\"click\", async () => {\n      const { scene, placements } = this.extractSelection(html);\n      const warnings = await previewPopulate(scene, placements, GridSelectionManager.instance.getCells());\n      const content = warnings.length ? warnings.join(\"<br>\") : \"Keine Warnungen.\";\n      await Dialog.prompt({ title: \"Preview\", content: `<p>${content}</p>` });\n    });\n\n    html.find(\"button[data-action='populate']\").on(\"click\", async () => {\n      const { scene, placements } = this.extractSelection(html);\n      try {\n        await populateScene(scene, placements, GridSelectionManager.instance.getCells());\n      } catch (err: any) {\n        ui.notifications.error(`Populate fehlgeschlagen: ${err.message}`);\n      }\n    });\n\n    html.find(\"button[data-action='resolve']\").on(\"click\", async () => {\n      const { placements } = this.extractSelection(html);\n      const unresolved: string[] = [];\n      for (const p of placements) {\n        const result = await resolveMonster(p.monster);\n        if (result.status !== \"resolved\") unresolved.push(p.monster.name);\n      }\n      if (unresolved.length) {\n        ui.notifications.warn(`Unresolved: ${unresolved.join(\", \")}`);\n      } else {\n        ui.notifications.info(\"Alle Placements aufgel\u00F6st.\");\n      }\n      this.render();\n    });\n  }\n\n  extractSelection(html: any): { scene: any; placements: any[] } {\n    const data = getStoredEncounterData();\n    const sIdx = Number(html.find(\"select[name='scene']\").val() ?? 0);\n    const eIdx = Number(html.find(\"select[name='encounter']\").val() ?? 0);\n    const selectedScene = data.scenes[sIdx];\n    const sceneId = selectedScene?.sceneRef?.sceneId;\n    const scene = game.scenes.get(sceneId) ?? canvas.scene;\n    const placements = selectedScene?.encounters?.[eIdx]?.placements ?? [];\n    return { scene, placements };\n  }\n}\n", "import { registerSettings } from \"./foundry/settings\";\nimport { MODULE_ID } from \"./foundry/constants\";\nimport { exportScenesJson, promptImportDialog } from \"./foundry/io\";\nimport { rebuildMonsterIndex } from \"./data/indexer\";\nimport { EncounterAdjusterApp } from \"./ui/app\";\nimport { GridSelectionManager } from \"./foundry/grid-selection\";\n\nlet app: EncounterAdjusterApp | null = null;\n\nHooks.once(\"init\", () => {\n  registerSettings();\n});\n\nHooks.once(\"ready\", () => {\n  Hooks.on(\"renderSettingsConfig\", (_app: any, html: any) => {\n    const block = $(\n      `<div class=\"form-group\">\\n        <label>PF2e Encounter Adjuster</label>\\n        <div class=\"form-fields\">\\n          <button type=\"button\" data-action=\"ea-export\">Szenenliste exportieren</button>\\n          <button type=\"button\" data-action=\"ea-import\">Encounter JSON importieren</button>\\n          <button type=\"button\" data-action=\"ea-index\">Monster-Index neu aufbauen</button>\\n          <button type=\"button\" data-action=\"ea-open\">Encounter Adjuster \u00F6ffnen</button>\\n        </div>\\n      </div>`\n    );\n    html.find(\".tab[data-tab='modules'] .settings-list\").append(block);\n\n    block.find(\"button[data-action='ea-export']\").on(\"click\", async () => exportScenesJson(false));\n    block.find(\"button[data-action='ea-import']\").on(\"click\", async () => promptImportDialog());\n    block.find(\"button[data-action='ea-index']\").on(\"click\", async () => {\n      const r = await rebuildMonsterIndex();\n      ui.notifications.info(`Monster-Index aktualisiert (${r.count} Eintr\u00E4ge).`);\n    });\n    block.find(\"button[data-action='ea-open']\").on(\"click\", async () => {\n      app ??= new EncounterAdjusterApp();\n      app.render(true);\n    });\n  });\n\n  Hooks.on(\"getSceneControlButtons\", (controls: any[]) => {\n    if (!game.user.isGM) return;\n    controls.push({\n      name: MODULE_ID,\n      title: \"Encounter Adjuster\",\n      icon: \"fas fa-dragon\",\n      layer: \"TokenLayer\",\n      tools: [\n        {\n          name: \"ea-grid-toggle\",\n          title: \"Grid-Square togglen\",\n          icon: \"fas fa-vector-square\",\n          button: true,\n          onClick: () => GridSelectionManager.instance.activate()\n        }\n      ]\n    });\n  });\n});\n"],
  "mappings": "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",
  "names": ["regionBounds"]
}
